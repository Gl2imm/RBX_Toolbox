
import bpy
import os
from bpy.types import (Scene,Panel,PropertyGroup)
from bpy.props import (BoolProperty,FloatProperty,StringProperty)
import requests
import subprocess
import webbrowser
import sys
import platform
import bmesh
import RBX_Toolbox

import zipfile
import io
import mathutils
from bpy.props import FloatVectorProperty
from mathutils import Vector
from bpy_extras.object_utils import AddObjectHelper, object_data_add
import urllib.request
import bpy.utils.previews
import asyncio
import re


       


        
rbx_asset_name = None
rbx_asset_type_name = None
rbx_asset_creator = None
rbx_bkd_hair_img = None
rbx_anim_error = None
unhide_store = []


_icons = None


#https://create.roblox.com/docs/reference/engine/enums/AssetType
rbx_ast_type = {
    'BodyParts' : 'Bundle',
    '2':'T-Shirt',
    '8':'Hat',
    '11':'Shirt',
    '12':'Pants',
    '17':'Head',
    '18':'Face',
    '19':'Gear',
    '25':'Arms',
    '26':'Legs',
    '27':'Torso',
    '28':'RightArm',
    '29':'LeftArm',
    '30':'LeftLeg',
    '31':'RightLeg',
    '41':'HairAccessory',
    '42':'FaceAccessory',
    '43':'NeckAccessory',
    '44':'ShoulderAccessory',
    '45':'FrontAccessory',
    '46':'BackAccessory',
    '47':'WaistAccessory',
    '48':'ClimbAnimation',
    '49':'DeathAnimation',
    '50':'FallAnimation',
    '51':'IdleAnimation',
    '52':'JumpAnimation',
    '53':'RunAnimation',
    '54':'SwimAnimation',
    '55':'WalkAnimation',
    '56':'PoseAnimation',
    '61':'EmoteAnimation',
    '62':'Video',
    '64':'TShirtAccessory',
    '65':'ShirtAccessory',
    '66':'PantsAccessory',
    '67':'JacketAccessory',
    '68':'SweaterAccessory',
    '69':'ShortsAccessory',
    '70':'LeftShoeAccessory',
    '71':'RightShoeAccessory',
    '72':'DressSkirtAccessory',
    '73':'FontFamily',
    '76':'EyebrowAccessory',
    '77':'EyelashAccessory',
    '78':'MoodAnimation',
    '79':'DynamicHead'
    }
accessory = [8,41,42,43,44,45,46,47]
lc = [64,65,66,67,68,69,70,71,72]
#################

    


               

        
             
class PROPERTIES_RBX(bpy.types.PropertyGroup):
    

    

         




 
      





                                              


                

    

    
    ## Import Character ##
    rbx_username: StringProperty(
        name="Username",
        description="Username of the character to import",
        default="papa_boss332",
        maxlen=100,
    )
    rbx_split : BoolProperty(
    name="Split accessories",
    description="Split accessories property",
    default = False
    )
    rbx_bundle : BoolProperty(
    name="Bundle accessory",
    description="Bundle accessory property",
    default = False
    )    
    
    
    ## Import Accessory ##
    rbx_accessory: StringProperty(
        name="Accessory",
        description="Accessory ID to import",
        default="11996887739",
        maxlen=100,
    ) 
    

    
        

   
    


        






############   IMPORT CHARACTERS AND ACCESSORIES   ############## 
class OBJECT_OT_add_object(bpy.types.Operator,AddObjectHelper):
    """Create a new Mesh Object"""
    bl_idname = "object.add_character"
    bl_label = "Add Roblox Character"
    bl_options = {'REGISTER', 'UNDO'}
    rbx_char : bpy.props.StringProperty(name= "Added")

    def execute(self, context): 
        global rbx_char_netw_error
        global rbx_asset_netw_error
        global rbx_asset_name
        global rbx_asset_type_name
        global rbx_asset_creator
        global rbx_username
        global rbx_accessory
        
        scene = context.scene
        rbx_char = self.rbx_char
        rbx_prefs = scene.rbx_prefs
        rbx_bundle = rbx_prefs.rbx_bundle
        rbx_split = rbx_prefs.rbx_split  
        rbx_username = rbx_prefs.rbx_username
        rbx_accessory = rbx_prefs.rbx_accessory
        rbx_username_is = "username"
        
        #rbx_char_path = addon_path + '/Imported_Characters' + fbs + rbx_username        
        
        ##### Convert username input #####
        if "https://www.roblox.com/" in rbx_username:
            rbx_username = rbx_username.lstrip("https://www.roblox.com/users/")
            rbx_username = rbx_username.split("/")[0]
            if not rbx_username.isdigit():
                rbx_char_netw_error = "Error: Invalid URL"
            else:                
                rbx_username_is = "id"
        elif rbx_username.isdigit():
            rbx_username = rbx_username
            rbx_username_is = "id"

        ##### Convert accessory input #####
        if rbx_bundle == False:
            if "https://www.roblox.com/" in rbx_accessory:
                rbx_accessory = rbx_accessory.lstrip("https://www.roblox.com/catalog/")
                rbx_accessory = rbx_accessory.split("/")[0]
                print(rbx_accessory)
                if not rbx_accessory.isdigit():
                    rbx_asset_netw_error = "Error: Invalid URL"
        else:
            if "https://www.roblox.com/" in rbx_accessory:
                rbx_accessory = rbx_accessory.lstrip("https://www.roblox.com/bundles/")
                rbx_accessory = rbx_accessory.split("/")[0]
                if not rbx_accessory.isdigit():
                    rbx_asset_netw_error = "Error: Invalid URL"

                    
        rbx_char_path = os.path.join(addon_path, 'Imported_Characters' + fbs + rbx_username)



        ##### Create Folders #####
        if rbx_char == 'folder':
            if not os.path.exists(addon_path + '/Imported_Characters'):
                os.makedirs(addon_path + '/Imported_Characters')
            os.startfile(os.path.dirname(addon_path + '/Imported_Characters/'))
        if rbx_char == 'folder_accessory':
            if not os.path.exists(addon_path + '/Imported_Accessories'):
                os.makedirs(addon_path + '/Imported_Accessories')
            os.startfile(os.path.dirname(addon_path + '/Imported_Accessories/'))         
        
        
        
        ##### Character Preview #####
        if rbx_char == 'preview': 
            if rbx_char_netw_error == None:
                rbx_usr_avtr, rbx_char_netw_error, rbx_username = asyncio.run(self.preview(rbx_username, rbx_username_is))
            
            if rbx_char_netw_error == None:
                ### Clear Previous Preview ###
                try:
                    rbx_tmp_img = bpy.data.images[rbx_username + '.png']
                except:
                    pass
                else:
                    bpy.data.images.remove(rbx_tmp_img)
                    
                    
                rbx_tmp_filepath = os.path.join(addon_path, 'tmp')
                if not os.path.exists(rbx_tmp_filepath):
                        os.makedirs(rbx_tmp_filepath)
                rbx_tmp_file = os.path.join(rbx_tmp_filepath, rbx_username + ".png")
                
                try:
                    with open(f"{rbx_tmp_file}", "wb") as f:
                        f.write(rbx_usr_avtr) 
                except:
                    print("OS Error")
                    rbx_char_netw_error = "Error saving temp avatar img"
                else:
                    rbx_usr_avtr = bpy.data.images.load(rbx_tmp_file)
                
                
        ##### Accessory Preview #####
        if rbx_char == 'preview_accessory': 
            if rbx_asset_netw_error == None:
                rbx_asset_img, rbx_asset_name, rbx_asset_type, rbx_asset_creator, rbx_asset_netw_error = asyncio.run(self.acc_preview(rbx_accessory, rbx_bundle))
                rbx_asset_type_name = rbx_ast_type.get(str(rbx_asset_type))
            
            if rbx_asset_netw_error == None:
                ### Clear Previous Preview ###
                try:
                    rbx_tmp_img = bpy.data.images[rbx_accessory + '.png']
                except:
                    pass
                else:
                    bpy.data.images.remove(rbx_tmp_img)
                    
                    
                rbx_tmp_filepath = os.path.join(addon_path, 'tmp')
                if not os.path.exists(rbx_tmp_filepath):
                        os.makedirs(rbx_tmp_filepath)
                rbx_tmp_file = os.path.join(rbx_tmp_filepath, rbx_accessory + ".png")
                
                try:
                    with open(f"{rbx_tmp_file}", "wb") as f:
                        f.write(rbx_asset_img) 
                except:
                    print("OS Error")
                    rbx_asset_netw_error = "Error saving temp Accessory img"
                else:
                    rbx_asset_img = bpy.data.images.load(rbx_tmp_file)                
                
        ##### Character Import #####        
        if rbx_char == 'import':
            if not os.path.exists(rbx_char_path):
                os.makedirs(rbx_char_path)               
                
            if rbx_char_netw_error == None:
                rbx_usr_hsh_urls, rbx_char_netw_error, rbx_username = asyncio.run(self.char_import(rbx_username, rbx_username_is))

            if rbx_char_netw_error == None: 
                              
                def get_cdn_url(hash):
                    i = 31
                    for char in hash:
                        i ^= ord(char)
                    return f"https://t{i%8}.rbxcdn.com/{hash}"
                
                avt_obj_hsh = rbx_usr_hsh_urls['obj']
                avt_mtl_hsh = rbx_usr_hsh_urls['mtl']
                avt_tex_hsh = rbx_usr_hsh_urls['textures']
                
                ### Get All URLs ###
                avt_mtl_url = get_cdn_url(avt_mtl_hsh)
                avt_obj_url = get_cdn_url(avt_obj_hsh)

                avt_tex_url = []
                for i in range(len(avt_tex_hsh)):
                    tmp_tex_url = get_cdn_url(avt_tex_hsh[i])
                    avt_tex_url.append(tmp_tex_url)               
                
                ### Download files ###
                rbx_mtl_file = os.path.join(rbx_char_path, rbx_username + ".mtl")
                rbx_obj_file = os.path.join(rbx_char_path, rbx_username + ".obj")                
                
                def save_to_file(file, url, type):
                    data, rbx_char_netw_error = asyncio.run(self.download(url, type))
                    if rbx_char_netw_error == None:
                        try:
                            with open(file, "wb") as f:
                                f.write(data) 
                        except:
                            print("OS Error")
                            rbx_char_netw_error = f"Error saving {type}"
                            
                save_to_file(rbx_mtl_file, avt_mtl_url, "mtl")
                save_to_file(rbx_obj_file, avt_obj_url, "obj")

                
                for i in range(len(avt_tex_url)):
                    rbx_tex_file = os.path.join(rbx_char_path, rbx_username + '_tex-' + str(i) + ".png")
                    save_to_file(rbx_tex_file, avt_tex_url[i], "png")
                    
                ### Write new Texture names into MTL ###
                if rbx_char_netw_error == None:
                    try:
                        with open(rbx_mtl_file, 'r', encoding='UTF-8') as f:
                            text = f.read()
                    except:
                        rbx_char_netw_error = "Error writing to MTL file"
                    else:
                        with open(rbx_mtl_file, 'w', encoding='UTF-8') as f:
                            for i in range(len(avt_tex_hsh)):
                                text = text.replace(avt_tex_hsh[i], rbx_username + '_tex-' + str(i) + ".png")
                            if "map_d" in text:
                                text = text.replace("map_d","") ## Remove transparency
                            f.write(text)
                        
                        if bldr_ver[0] < '4':
                            rbx_imp_avat = bpy.ops.import_scene.obj(filepath=rbx_obj_file)
                        else:
                            rbx_imp_avat = bpy.ops.wm.obj_import(filepath=rbx_obj_file)
                    
                        ### Selecting Character ###
                        rbx_object = bpy.context.selected_objects[0]
                        bpy.ops.object.select_all(action='DESELECT')
                        bpy.context.view_layer.objects.active = None
                        bpy.data.objects[rbx_object.name].select_set(True)
                        bpy.context.view_layer.objects.active = bpy.data.objects[rbx_object.name]
                                                
                        ### Position Character ###
                        bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='MEDIAN')
                        bpy.ops.view3d.snap_selected_to_cursor(use_offset=False)
                        #bpy.ops.transform.translate(value=(0, 0, 3.28467), orient_axis_ortho='X', orient_type='GLOBAL', orient_matrix=((1, 0, 0), (0, 1, 0), (0, 0, 1)), orient_matrix_type='GLOBAL', constraint_axis=(False, False, True))
                        bpy.ops.transform.translate(value=(0, 0, 3.28467), orient_type='GLOBAL', orient_matrix=((1, 0, 0), (0, 1, 0), (0, 0, 1)), orient_matrix_type='GLOBAL', constraint_axis=(False, False, True))
                        bpy.ops.transform.rotate(value=3.14159, orient_axis='Z', orient_type='GLOBAL', orient_matrix=((1, 0, 0), (0, 1, 0), (0, 0, 1)), orient_matrix_type='GLOBAL', constraint_axis=(False, False, True))
                        
                        ### Setting up materials ###
                        for rbx_mat_slot in bpy.context.object.material_slots:
                            rbx_mat_slot.material.show_transparent_back = False
                            rbx_mat_slot.material.use_backface_culling = True 
                        
                        ### Setting up materials for New Heads and Skinned characters ###    
                        with open(rbx_mtl_file, 'r', encoding='UTF-8') as f:
                            lines = f.readlines()
                            for i in range(len(lines)):
                                if "newmtl" in lines[i]:
                                    mat_nm = lines[i].split("newmtl")
                                    mat_nm = mat_nm[1].strip()
                                    for x in range(i,i+2):
                                        if "Material Color" in lines[x]:
                                            for n in range(x,len(lines)):
                                                if "Ka" in lines[n]:
                                                    rbx_shade = lines[n].split(" ")
                                                    rbx_shade_r = rbx_shade[1].strip()
                                                    rbx_shade_g = rbx_shade[2].strip()
                                                    rbx_shade_b = rbx_shade[3].strip()
                                                    if (rbx_shade_r, rbx_shade_g, rbx_shade_b) != ('1','1','1'):
                                                        rbx_shade_r = float(rbx_shade_r) - 0.187934
                                                        rbx_shade_g = float(rbx_shade_g) - 0.28103
                                                        rbx_shade_b = float(rbx_shade_b) - 0.269785                                                  
                                                        for rbx_mat_slot in bpy.context.object.material_slots:
                                                            if mat_nm in rbx_mat_slot.name:
                                                                rbx_mat = rbx_mat_slot.material
                                                                rbx_nodes = rbx_mat.node_tree.nodes
                                                                bsdf = rbx_nodes['Principled BSDF']
                                                                
                                                                if float(bldr_fdr) < 3.4:
                                                                    rbx_MixNode = rbx_nodes.new('ShaderNodeMixRGB')
                                                                    rbx_MixNode.inputs[1].default_value = (rbx_shade_r, rbx_shade_g, rbx_shade_b, 1)
                                                                else:
                                                                    rbx_MixNode = rbx_nodes.new('ShaderNodeMix')
                                                                    rbx_MixNode.data_type='RGBA'
                                                                    rbx_MixNode.inputs[6].default_value = (rbx_shade_r, rbx_shade_g, rbx_shade_b, 1)
                                                                rbx_MixNode.location = (-200,300)
                                                                
                                                                rbx_img = rbx_nodes['Image Texture']
                                                                rbx_img.location = (-500,300)
                                                                rbx_img_link = rbx_img.outputs[0].links[0] #existing link to bsdf
                                                                rbx_mat.node_tree.links.remove(rbx_img_link) #remove existing link to bsdf
                                                                
                                                                if float(bldr_fdr) < 3.4:
                                                                    rbx_mat.node_tree.links.new(rbx_img.outputs[1], rbx_MixNode.inputs[0]) #Alpha
                                                                    rbx_mat.node_tree.links.new(rbx_img.outputs[0], rbx_MixNode.inputs[2]) #Color
                                                                    rbx_mat.node_tree.links.new(rbx_MixNode.outputs[0], bsdf.inputs[0])
                                                                else:
                                                                    rbx_mat.node_tree.links.new(rbx_img.outputs[1], rbx_MixNode.inputs[0]) #Alpha
                                                                    rbx_mat.node_tree.links.new(rbx_img.outputs[0], rbx_MixNode.inputs[7]) #Color
                                                                    rbx_mat.node_tree.links.new(rbx_MixNode.outputs[2], bsdf.inputs[0])
                                                    break
 
                        ### Removing doubles ###
                        if bpy.context.mode == 'OBJECT':
                            bpy.ops.object.editmode_toggle()
                            bpy.ops.mesh.select_all(action='SELECT')                
                        elif bpy.context.mode == 'EDIT_MESH':
                            bpy.ops.mesh.select_all(action='SELECT')
                        bpy.ops.mesh.remove_doubles()
                        #bpy.ops.mesh.normals_make_consistent(inside=False)
                        bpy.ops.object.editmode_toggle()
                        bpy.ops.mesh.customdata_custom_splitnormals_clear()
                        bpy.context.object.data.use_auto_smooth = False
                        bpy.ops.object.shade_smooth()

                              
                if rbx_split == True:
                    if rbx_char_netw_error == None:
                        
                        obj = context.active_object
                        i = 1
            
                        # Check if the selected object has any materials assigned to it
                        if not obj.material_slots:
                            rbx_char_netw_error = "No materials assigned to selected object."
                        else:
                            bpy.ops.object.editmode_toggle()
                            bpy.ops.mesh.select_all(action='SELECT')
                            bpy.ops.mesh.separate(type='MATERIAL')
                            bpy.ops.object.editmode_toggle()
                            for selected in context.selected_objects:
                                if selected.name == obj.name:
                                    # Deselect selected object
                                    obj.select_set(False)
                                else:
                                    # Set the new created object to active
                                    context.view_layer.objects.active = selected
                                    context.active_object.name = f"{obj.name}_Accessory_{i}"
                                    i += 1
                            bpy.ops.object.select_all(action='DESELECT')
            

        ##### Accossory Import #####        
        if rbx_char == 'import_accessory': 
            if rbx_bundle == True:
                rbx_asset_name, rbx_asset_type, rbx_asset_creator, rbx_asset_items, rbx_asset_netw_error = asyncio.run(self.get_acc_bundl_info(rbx_accessory))
                print(rbx_asset_items)    
            else:               
                rbx_asset_name, rbx_asset_type, rbx_asset_creator, rbx_asset_netw_error = asyncio.run(self.get_acc_info(rbx_accessory, rbx_bundle))
            rbx_asset_type_name = rbx_ast_type.get(str(rbx_asset_type))
            
            if rbx_asset_netw_error == None:    
                rbx_char_path = os.path.join(addon_path, 'Imported_Accessories' + fbs + rbx_asset_name)
                if not os.path.exists(rbx_char_path):
                    try:
                        os.makedirs(rbx_char_path)
                    except:
                        print("OS Error")
                        rbx_asset_netw_error = "Error Making Accessory Folder" 
                
            if rbx_asset_netw_error == None:
                asset_data, rbx_asset_netw_error = asyncio.run(self.get_asset_data(rbx_accessory))
                asset_data = str(asset_data)

            if rbx_asset_netw_error == None:
                def get_cdn_url(hash):
                    i = 31
                    for char in hash:
                        i ^= ord(char)
                    return f"https://t{i%8}.rbxcdn.com/{hash}"
                ############## PARSING RBXM ################
                ### WARNING!!
                ### If you also want to use this parsing method
                ### You can, this is created by me
                ### But you must give a proper credits with links to my socials (e.g. Twitter, Discord)
                def regex(exp,str):
                    clean = r"[0-9]+\W*(PROP)"
                    res = re.search(exp, str, re.MULTILINE)
                    if res == None:
                        pass
                    else:
                        if rbx_asset_type in accessory and rbx_asset_creator == "Roblox":
                            res = res.group()
                            if 'id=' in res:
                                res = res.split("id=")[1]
                            if 'id://' in res:
                                res = res.split("id://")[1]
                            res = res.split("<")[0]
                        else:
                            res = res.group()
                            print(res)
                            res = re.search(clean, res, re.MULTILINE)
                            if res == None:
                                pass
                            else:
                                res = res.group()
                                res = res.split("PROP")[0]
                    return res
             
                if rbx_asset_type in accessory and rbx_asset_creator == "Roblox":
                    expMesh = r'"MeshId"><url>.*?\W*(<)'
                    expTexMap = r'"TextureId"><url>.*?\W*(<)'
                else:
                    expTexMap = r"TextureId.*?\W*(PROP)"
                    expColMap = r"ColorMap.*?\W*(PROP)"
                    expNorMap = r"NormalMap.*?\W*(PROP)"
                    expMetMap = r"MetalnessMap.*?\W*(PROP)"
                    expRoughMap = r"RoughnessMap.*?\W*(PROP)"
                    expMesh = r"MeshId.*?\W*(PROP)"
                    #expOutCage = r"CageMeshId.*?\W*(PROP)"
                    #expInCage = r"ReferenceMeshId.*?\W*(PROP)"        
                
                is_acry = False
                is_lc = False
                if rbx_asset_type in accessory:
                    is_acry = True
                if rbx_asset_type in lc:
                    is_lc = True                    
                    
                ### Getting Accessory Textures ID's (Library ID) ### 
                texMapId = None
                meshId = None 
                colMapId = None
                norMapId = None
                metMapId = None
                roughMapId = None
                if is_acry == True:    
                   texMapId = regex(expTexMap, asset_data)
                   meshId = regex(expMesh, asset_data)
                if is_lc == True:
                    colMapId = regex(expColMap, asset_data)
                    norMapId = regex(expNorMap, asset_data)
                    metMapId = regex(expMetMap, asset_data)
                    roughMapId = regex(expRoughMap, asset_data)
                    meshId = regex(expMesh, asset_data)
                    #outCageId = regex(expOutCage, lines)
                    #inCageId = regex(expInCage, lines)
                print(texMapId)
                print(meshId)
                tex_items = [meshId,texMapId,colMapId,metMapId,roughMapId,norMapId]
                tex_range = ['Obj','Texture','Diffuse','Metallic','Roughness','Normal']

                ### Create Temp files ###
                rbx_mtl_file = os.path.join(rbx_char_path, rbx_asset_name + ".mtl")
                
                ### Get Textures Data and write them to files ###
                n = 0
                for item in tex_items:
                    if rbx_asset_netw_error == None:
                        if item != None:
                            if n == 0:
                                try:
                                    file_data, rbx_asset_netw_error = asyncio.run(self.get_asset_hashes(rbx_accessory)) # Get OBJ Hash
                                except:
                                    rbx_asset_netw_error = "Error Getting OBJ file"
                                else:
                                    acc_obj_hsh = file_data['obj'] # Get OBJ Hash
                                    acc_obj_url = get_cdn_url(acc_obj_hsh) # Convert OBJ Hash to URL
                                    file_data, rbx_asset_netw_error = asyncio.run(self.download(acc_obj_url, 'obj')) # Get OBJ Data
                                if rbx_asset_netw_error == None:
                                    rbx_tmp_file = os.path.join(rbx_char_path, rbx_asset_name + ".obj") # Save OBJ Data
                                    rbx_obj_file = os.path.join(rbx_char_path, rbx_asset_name + ".obj") # For Import OBJ Later
                                else:
                                    rbx_asset_netw_error = f"Error saving {tex_range[n]}" 
                            else:
                                file_data, rbx_asset_netw_error = asyncio.run(self.get_asset_data(item)) # Get all other Textures
                                if rbx_asset_netw_error == None:
                                    rbx_tmp_file = os.path.join(rbx_char_path, rbx_asset_name + f"_{tex_range[n]}.png")
                                else:
                                    rbx_asset_netw_error = f"Error getting {tex_range[n]} Map"
                            if rbx_asset_netw_error == None:
                                try:
                                    #print(f"Writing {tex_range[n]} data")
                                    with open(rbx_tmp_file, "wb") as f:
                                        f.write(file_data) 
                                except:
                                    print("OS Error")
                                    rbx_asset_netw_error = f"Error saving {tex_range[n]}"
                    n += 1
                    
                ### Import Accessory ###    
                if rbx_asset_netw_error == None:
 
                    ### Start Accessory Import ###
                    if bldr_ver[0] < '4':
                        rbx_imp_acc = bpy.ops.import_scene.obj(filepath=rbx_obj_file)
                    else:
                        rbx_imp_acc = bpy.ops.wm.obj_import(filepath=rbx_obj_file)

                    ### Creating new Material ###
                    rbx_obj = bpy.context.selected_objects[0]
                    bpy.ops.object.select_all(action='DESELECT')
                    bpy.context.view_layer.objects.active = None
                    bpy.data.objects[rbx_obj.name].select_set(True)
                    bpy.context.view_layer.objects.active = bpy.data.objects[rbx_obj.name]
                    
                    if rbx_obj.material_slots:
                        bpy.ops.object.material_slot_remove()
                    mat = bpy.data.materials.new(name=f"{rbx_asset_name}_mat")
                    rbx_obj.data.materials.append(mat) 
                    mat = rbx_obj.material_slots[0].material 
                    mat.use_nodes = True
                    mat.use_backface_culling = True
                    nodes = mat.node_tree.nodes
                    bsdf = nodes.get("Principled BSDF")
                    bsdf.inputs[9].default_value = 1


                    for i in range(len(tex_items)):
                        if tex_items[i] != None:
                            if i == 0:
                                pass
                            else:
                                rbx_tex = os.path.join(rbx_char_path, rbx_asset_name + f"_{tex_range[i]}.png")
                                rbx_image = bpy.data.images.load(rbx_tex)
                                rbxtexNode = nodes.new('ShaderNodeTexImage')
                                rbxtexNode.image = rbx_image
                                rbxtexNode.name = tex_range[i]
                                if i > 1:
                                    loc = i-2
                                else:
                                    loc = i-1
                                rbxtexNode.location = (-500,300-300*loc)
                                if i == 1 or i == 2:
                                    mat.node_tree.links.new(rbxtexNode.outputs[0], bsdf.inputs["Base Color"])
                                else:
                                    if i == 5:
                                        norm_node = nodes.new(type="ShaderNodeNormalMap")
                                        norm_node.location = (-200,300-300*loc)        
                                        mat.node_tree.links.new(rbxtexNode.outputs[0], norm_node.inputs[1])
                                        mat.node_tree.links.new(norm_node.outputs[0], bsdf.inputs[tex_range[i]])
                                        norm_node.space = 'TANGENT'
                                    else:
                                        mat.node_tree.links.new(rbxtexNode.outputs[0], bsdf.inputs[tex_range[i]])
                                    rbx_image.colorspace_settings.name = 'Non-Color'
                                    
                   
                    ### Position Asset ###
                    bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='MEDIAN')
                    bpy.ops.view3d.snap_selected_to_cursor(use_offset=False)
                    bpy.ops.transform.rotate(value=3.14159, orient_axis='Z', orient_type='GLOBAL', orient_matrix=((1, 0, 0), (0, 1, 0), (0, 0, 1)), orient_matrix_type='GLOBAL')
                    
                    
                    ### Removing doubles ###
                    if bpy.context.mode == 'OBJECT':
                        bpy.ops.object.editmode_toggle()
                        bpy.ops.mesh.select_all(action='SELECT')                
                    elif bpy.context.mode == 'EDIT_MESH':
                        bpy.ops.mesh.select_all(action='SELECT')
                    bpy.ops.mesh.remove_doubles()
                    #bpy.ops.mesh.normals_make_consistent(inside=False)
                    bpy.ops.object.editmode_toggle()
                    bpy.ops.mesh.customdata_custom_splitnormals_clear()
                    bpy.context.object.data.use_auto_smooth = False

                                        
                           
        return {'FINISHED'}
    



    ###########  MAIN ASYNC FUNCTIONS ###########
    ### Preview for Character ###
    async def preview(self, rbx_username, rbx_username_is):
        result, rbx_char_netw_error, rbx_username = await self.get_user_id(rbx_username, rbx_username_is) #User ID
        if rbx_char_netw_error == None:
            result, rbx_char_netw_error = await self.get_user_avatar_url(result) #User Avatar URL
            if rbx_char_netw_error == None:
                result, rbx_char_netw_error = await self.get_user_avatar_img(result) #User Avatar IMG Data
        return result, rbx_char_netw_error, rbx_username

    ### Preview for Accessory ###
    async def acc_preview(self, rbx_accessory, rbx_bundle):
        rbx_asset_img_url, rbx_asset_netw_error = await self.get_acc_url(rbx_accessory, rbx_bundle) #Accessory IMG URL
        if rbx_asset_netw_error == None:
            result, rbx_asset_netw_error = await self.get_acc_img(rbx_asset_img_url) #Accessory IMG Data
            if rbx_asset_netw_error == None:
                rbx_asset_name, rbx_asset_type, rbx_asset_creator, rbx_asset_netw_error = await self.get_acc_info(rbx_accessory, rbx_bundle) #Accessory Infos
            else:
                result, rbx_asset_name, rbx_asset_type, rbx_asset_creator = None, None, None, None
        else:
            result, rbx_asset_name, rbx_asset_type, rbx_asset_creator = None, None, None, None
            
        return result, rbx_asset_name, rbx_asset_type, rbx_asset_creator, rbx_asset_netw_error
    
    ### Import Character ###
    async def char_import(self, rbx_username, rbx_username_is):
        result, rbx_char_netw_error, rbx_username = await self.get_user_id(rbx_username, rbx_username_is) #User ID
        if rbx_char_netw_error == None:
            result, rbx_char_netw_error = await self.get_user_hashes(result)
        return result, rbx_char_netw_error, rbx_username

        
    ########### INDIVIDUAL FUNCTIONS ###########
    async def get_user_id(self, rbx_username, rbx_username_is):
        if rbx_username_is == "id":
            try:
                data = requests.get(f"https://users.roblox.com/v1/users/{rbx_username}")
            except:
                rbx_char_netw_error = "Get User ID Error, no respose"
                rbx_usr_id = None
            else: 
                if data.status_code == 200:
                    data = data.json()
                    rbx_usr_id = data['id']
                    rbx_username = data['name']
                    rbx_char_netw_error = None
                else:
                    if data.status_code == 404:
                        rbx_username_is = "username"
                    else:
                        rbx_usr_id = None
                        rbx_char_netw_error = f"{data.status_code}: Error getting User ID" 
        if rbx_username_is == "username":
            payload = {
                "usernames": [rbx_username],
                "excludeBannedUsers" : 'true'
                }
            try:
                data = requests.post("https://users.roblox.com/v1/usernames/users", json=payload)
            except:
                rbx_char_netw_error = "Get User ID Error, no respose"
                rbx_usr_id = None
            else:
                if data.status_code == 200:
                    data = data.json()
                    try:
                        rbx_usr_id = data.get('data')[0]['id']
                    except:
                        rbx_usr_id = None
                        rbx_char_netw_error = "Error: Unable to find this user"
                    else:
                        rbx_char_netw_error = None           
                else:
                    rbx_usr_id = None
                    rbx_char_netw_error = f"{data.status_code}: Error getting User ID"
        return rbx_usr_id, rbx_char_netw_error, rbx_username
    
                    
    async def get_user_avatar_url(self, rbx_usr_id):
        rbx_size = '250x250'
        rbx_format = 'Png'
        rbx_isCircular = 'false'                                            
        url = f"https://thumbnails.roblox.com/v1/users/avatar?userIds={rbx_usr_id}&size={rbx_size}&format={rbx_format}&isCircular={rbx_isCircular}"
        data = requests.get(url)
        if data.status_code == 200:
            data = data.json()
            rbx_usr_img_url = data["data"][0]["imageUrl"]
            rbx_char_netw_error = None
        else:
            rbx_usr_img_url = None
            rbx_char_netw_error = f"{data.status_code}: Error getting Avatar URL"
        return rbx_usr_img_url, rbx_char_netw_error
                
                
    async def get_user_avatar_img(self, rbx_usr_img_url): 
        image_data = requests.get(rbx_usr_img_url)
        if image_data.status_code == 200:
            image_data = image_data.content
            rbx_char_netw_error = None
        else:
            rbx_char_netw_error = f"{image_data.status_code}: Error getting Avatar IMG"
        return image_data, rbx_char_netw_error



    async def get_user_hashes(self, rbx_usr_id): 
        data = requests.get(f"https://thumbnails.roblox.com/v1/users/avatar-3d?userId={rbx_usr_id}")                   
        if data.status_code == 200:
            data = data.json()
            rbx_usr_hsh_urls = data['imageUrl']  #Get Link to OBJ and Textures Hashes
            rbx_char_netw_error = None
            rbx_usr_hsh_urls = requests.get(rbx_usr_hsh_urls)
            if rbx_usr_hsh_urls.status_code == 200:
                rbx_usr_hsh_urls = rbx_usr_hsh_urls.json() #Get OBJ and Textures Hashes links
                rbx_char_netw_error = None
            else:
                rbx_usr_hsh_urls = None
                rbx_char_netw_error = f"{rbx_usr_hsh_urls.status_code}: Error getting user hashes"
        else:
            rbx_usr_hsh_urls = None
            rbx_char_netw_error = f"{rbx_usr_hsh_urls.status_code}: Error getting user hashes"
        return rbx_usr_hsh_urls, rbx_char_netw_error


    async def download(self, url, type): 
        data = requests.get(url) 
        if data.status_code == 200:
            data = data.content
            rbx_char_netw_error = None
        else:
            rbx_char_netw_error = f"{data.status_code}: Error downloading {type} file"
        return data, rbx_char_netw_error



    async def get_acc_url(self, rbx_accessory, rbx_bundle):
        rbx_size = '250x250'
        rbx_format = 'Png'
        rbx_isCircular = 'false'
        if rbx_bundle == True:
            rbx_url = f"https://thumbnails.roblox.com/v1/bundles/thumbnails?bundleIds={rbx_accessory}&size=150x150&format={rbx_format}&isCircular={rbx_isCircular}"
        else:
            rbx_url = f"https://thumbnails.roblox.com/v1/assets?assetIds={rbx_accessory}&returnPolicy=PlaceHolder&size={rbx_size}&format={rbx_format}&isCircular={rbx_isCircular}"         
        data = requests.get(rbx_url)
        if data.status_code == 200:
            data = data.json()
            try:
                rbx_asset_img_url = data["data"][0]["imageUrl"]
            except:
                rbx_asset_netw_error = f"{data.status_code}: Error, Invalid accessory"
                rbx_asset_img_url = None
            else:
                rbx_asset_netw_error = None
        else:
            rbx_asset_img_url = None
            rbx_asset_netw_error = f"{data.status_code}: Error getting Accessory IMG URL"
        return rbx_asset_img_url, rbx_asset_netw_error


    async def get_acc_img(self, rbx_asset_img_url): 
        data = requests.get(rbx_asset_img_url)
        if data.status_code == 200:
            image_data = data.content
            rbx_asset_netw_error = None
        else:
            rbx_char_netw_error = f"{data.status_code}: Error getting Accessory IMG Data"
        return image_data, rbx_asset_netw_error

    async def get_acc_info(self, rbx_accessory, rbx_bundle):          
        if rbx_bundle == True:
            url = f"https://catalog.roblox.com/v1/bundles/{rbx_accessory}/details"
            data = requests.get(url)
            if data.status_code == 200:
                data = data.json()
                rbx_asset_name = data['name']
                rbx_asset_type = data['bundleType']
                rbx_asset_creator = data['creator']['name']
                rbx_asset_netw_error = None
            else:
                rbx_asset_name = None
                rbx_asset_creator = None
                rbx_asset_type = None
                rbx_asset_netw_error = f"{data.status_code}: Error getting Accessory Info"
        else:                           
            url = f"https://economy.roblox.com/v2/assets/{rbx_accessory}/details"
            data = requests.get(url)
            if data.status_code == 200:
                data = data.json()
                rbx_asset_name = data['Name']
                rbx_asset_type = data['AssetTypeId']
                rbx_asset_creator = data['Creator']['Name']
                rbx_asset_netw_error = None
            else:
                rbx_asset_name = None
                rbx_asset_creator = None
                rbx_asset_type = None
                rbx_asset_netw_error = f"{data.status_code}: Error getting Accessory Info"
        return rbx_asset_name, rbx_asset_type, rbx_asset_creator, rbx_asset_netw_error





    async def get_acc_bundl_info(self, rbx_accessory):          
        url = f"https://catalog.roblox.com/v1/bundles/{rbx_accessory}/details"
        data = requests.get(url)
        if data.status_code == 200:
            data = data.json()
            rbx_asset_name = data['name']
            rbx_asset_type = data['bundleType']
            rbx_asset_creator = data['creator']['name']
            rbx_asset_items = data['items']
            rbx_asset_netw_error = None
        else:
            rbx_asset_name = None
            rbx_asset_creator = None
            rbx_asset_type = None
            rbx_asset_items = None
            rbx_asset_netw_error = f"{data.status_code}: Error getting Accessory Info"
        return rbx_asset_name, rbx_asset_type, rbx_asset_creator, rbx_asset_items, rbx_asset_netw_error
    
    

    async def get_asset_data(self, rbx_accessory):
        url = f"https://assetdelivery.roblox.com/v1/asset?id={rbx_accessory}" 
        data = requests.get(url)
        if data.status_code == 200:
            asset_data = data.content
            rbx_asset_netw_error = None
        else:
            asset_data = None
            rbx_char_netw_error = f"{data.status_code}: Error getting Asset Data"
        return asset_data, rbx_asset_netw_error


    async def get_asset_hashes(self, rbx_accessory):             
        url = f"https://thumbnails.roblox.com/v1/assets-thumbnail-3d?assetId={rbx_accessory}"
        data = requests.get(url)
        if data.status_code == 200:
            data = data.json()
            rbx_acc_hsh_urls = data['imageUrl']  #Get Link to OBJ and Textures Hashes
            rbx_asset_netw_error = None
            data = requests.get(rbx_acc_hsh_urls)
            if data.status_code == 200:
                rbx_acc_hsh_urls = data.json() #Get OBJ and Textures Hashes links
                rbx_asset_netw_error = None
            else:
                rbx_acc_hsh_urls = None
                rbx_asset_netw_error = f"{data.status_code}: Error getting Asset hashes"
        else:
            rbx_acc_hsh_urls = None
            rbx_asset_netw_error = f"{data.status_code}: Error getting Asset hashes"
        return rbx_acc_hsh_urls, rbx_asset_netw_error



    




        

     
        
        
                 


    
        

              



    




        
                           
        

   



 
             
                
               
    

 





































    
    #PANEL UI
####################################
class TOOLBOX_MENU(bpy.types.Panel):
    bl_label = "Roblox Toolbox (" + disp_ver + ")"
    bl_idname = "RBX_PT_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "RBX Tools"
                     


                       
                
                
                
        ######### Import Characters and Accessories #########
        row = layout.row()
        icon = 'DOWNARROW_HLT' if context.scene.subpanel_imp_char else 'RIGHTARROW'
        row.prop(context.scene, 'subpanel_imp_char', icon=icon, icon_only=True)
        row.label(text='Import From Roblox', icon='IMPORT')
        # some data on the subpanel
        if context.scene.subpanel_imp_char:
            #row = layout.row()
            #row.label(text = 'Take Note!!', icon='ERROR')
            #row = layout.row()
            #row.label(text = 'Often Roblox refuses to share files')
            #row = layout.row()
            #row.label(text = 'So try to get it another time')
            box = layout.box()
            box.label(text = 'Enter ID, URL or Username')
            box.prop(rbx_prefs, 'rbx_username', text ='')
            box.operator('object.add_character', text = "Preview").rbx_char = "preview" 
            box.prop(rbx_prefs, 'rbx_split', text ='Separate Accessories')              
            split = box.split(factor = 0.5)
            col = split.column(align = True)            
            col.operator('object.add_character', text = "Import").rbx_char = "import"
            split.operator('object.add_character', text = "Open Folder").rbx_char = "folder"
            
            try:
                #rbx_avat_img_prev = bpy.data.images[rbx_prefs.rbx_username + '.png']
                rbx_avat_img_prev = bpy.data.images[rbx_username + '.png']
            except:
                box.separator()
                box.separator()
                box.separator()
                box.label(text = '')
                box.label(text = '')
                box.label(text = '')
                box.label(text = '')
                box.label(text = '')
                box.label(text = '')
                '''
                try:
                    rbx_avat_img_prev = bpy.data.images['blanc.png'] 
                except:
                    pass
                else:
                    rbx_avat_img_prev.preview_ensure()
                    box.template_icon(rbx_avat_img_prev.preview.icon_id, scale=10.0)
                '''
            else:
                rbx_avat_img_prev.preview_ensure()
                box.template_icon(rbx_avat_img_prev.preview.icon_id, scale=10.0)


            if rbx_char_netw_error:
                box.label(text = rbx_char_netw_error, icon='ERROR')
                try:
                    rbx_asset_img_prev = bpy.data.images[rbx_username + '.png']
                except:
                    pass 
                                                  
            
            ######### Import Accessory #########    
            box = layout.box()
            box.label(text = 'Accessory ID or URL')
            box.prop(rbx_prefs, 'rbx_accessory', text ='')
            #box.prop(rbx_prefs, 'rbx_bundle', text ='Tick for Bundle') 
            box.operator('object.add_character', text = "Preview").rbx_char = "preview_accessory"      
            split = box.split(factor = 0.5)
            col = split.column(align = True)            
            col.operator('object.add_character', text = "Import").rbx_char = "import_accessory"
            split.operator('object.add_character', text = "Open Folder").rbx_char = "folder_accessory"

            try:
                #rbx_asset_img_prev = bpy.data.images[rbx_prefs.rbx_accessory + '.png']
                rbx_asset_img_prev = bpy.data.images[rbx_accessory + '.png']
            except:
                box.separator()
                box.separator()
                box.separator()
                box.label(text = '')
                box.label(text = '')
                box.label(text = '')
                box.label(text = '')
                box.label(text = '')
                box.label(text = '')
            else:
                rbx_asset_img_prev.preview_ensure()
                box.template_icon(rbx_asset_img_prev.preview.icon_id, scale=10.0)
            
                if rbx_asset_name:
                    if rbx_prefs.rbx_accessory:
                        box.label(text = 'Name: ' + rbx_asset_name)
                        box.label(text = 'Type: ' + rbx_asset_type_name)
                        box.label(text = 'Creator: ' + rbx_asset_creator)
                    
            if rbx_asset_netw_error:
                box.label(text = rbx_asset_netw_error, icon='ERROR')
                try:
                    rbx_asset_img_prev = bpy.data.images[rbx_accessory + '.png']
                except:
                    pass 
                                           
                                        

                

        

            
            
            
            
            


 
                            
                                  


                    
                                
                   

                       
            
 
 
 

                
                
                
                                    

                



                
 
                
                
                



            


              
                
                        
 



    #CLASS REGISTER 
##########################################
classes = (
        RBXToolsPreferences,
        RBX_OPERATORS,
        PROPERTIES_RBX, 
        URL_HANDLER,
        RBX_BUTTON_HDRI,
        OBJECT_OT_add_object,
        BUTTON_DMMY,
        BUTTON_WEAR,
        #BUTTON_RIGS,
        BUTTON_HAIR, 
        RBX_BUTTON_LC,
        RBX_BUTTON_LC_ANIM,
        RBX_BUTTON_AVA,
        BUTTON_BNDS,
        BUTTON_CMR,
        BUTTON_BN, 
        RBX_BUTTON_OF,
        TOOLBOX_MENU,
        RBX_MT_MENU,
        RBX_MT_MENU2,
        RBX_MT_MENU2_1,
        RBX_MT_MENU2_2,
        RBX_MT_MENU2_3,
        RBX_MT_MENU3,
        RBX_MT_MENU4
        )  
             

def register():
    for c in classes:
        bpy.utils.register_class(c)
    bpy.types.Scene.rbx_prefs = bpy.props.PointerProperty(type= PROPERTIES_RBX)
    Scene.subpanel_readme = BoolProperty(default=False)
    Scene.subpanel_hdri = BoolProperty(default=False)
    Scene.subpanel_imp_char = BoolProperty(default=False)
    Scene.subpanel_imp_char = BoolProperty(default=False)
    Scene.subpanel_bounds = BoolProperty(default=False)
    Scene.subpanel_dummy = BoolProperty(default=False)
    #Scene.subpanel_rigs = BoolProperty(default=False)
    Scene.subpanel_hair = BoolProperty(default=False)
    Scene.subpanel_lc = BoolProperty(default=False)
    Scene.subpanel_ava = BoolProperty(default=False)
    Scene.subpanel_cams = BoolProperty(default=False)
    Scene.subpanel_bn = BoolProperty(default=False)
    Scene.subpanel_bn_st1 = BoolProperty(default=False)
    Scene.subpanel_other = BoolProperty(default=False)
    Scene.subpanel_export = BoolProperty(default=False)
    Scene.subpanel_pie = BoolProperty(default=False)
    kc = bpy.context.window_manager.keyconfigs.addon
    km = kc.keymaps.new(name='Window', space_type='EMPTY')
    kmi = km.keymap_items.new('wm.call_menu_pie', 'Y', 'PRESS',
        ctrl=False, alt=False, shift=False, repeat=False)
    kmi.properties.name = 'RBX_MT_MENU'
    addon_keymaps['F85A6'] = (km, kmi)
    
    
def unregister():
    rbx_tmp_path = os.path.join(addon_path, 'tmp')
    rbx_tmp_list = os.listdir(rbx_tmp_path)
    for i in rbx_tmp_list:
        os.remove(os.path.join(rbx_tmp_path, i))
    
    for c in classes:
        bpy.utils.unregister_class(c)
    del bpy.types.Scene.rbx_prefs
    del Scene.subpanel_readme
    del Scene.subpanel_hdri
    del Scene.subpanel_imp_char
    del Scene.subpanel_imp_char
    del Scene.subpanel_bounds
    del Scene.subpanel_dummy
    #del Scene.subpanel_rigs
    del Scene.subpanel_hair
    del Scene.subpanel_lc
    del Scene.subpanel_ava
    del Scene.subpanel_cams
    del Scene.subpanel_bn
    del Scene.subpanel_bn_st1
    del Scene.subpanel_other
    del Scene.subpanel_export 
    del Scene.subpanel_pie 
    wm = bpy.context.window_manager
    kc = wm.keyconfigs.addon
    for km, kmi in addon_keymaps.values():
        km.keymap_items.remove(kmi)
    addon_keymaps.clear() 

        

if __name__ == "__main__":
    register()
